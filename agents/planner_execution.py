"""
Planner Execution Node: Executes the structured plan generated by Planner.
Invokes specialized agents and updates state with results.
"""

import logging
from typing import Dict, Any
from datetime import datetime
from langchain_core.messages import AIMessage, ToolMessage

from core.state import GraphState, ExecutionPlan
from agents.flight_agent import execute_flight_search
from agents.hotel_agent import execute_hotel_search
from agents.activity_agent import execute_activity_search
from agents.itinerary_agent import execute_itinerary_composition

logger = logging.getLogger(__name__)


def planner_execution_node(state: GraphState) -> Dict[str, Any]:
    """
    Execute the structured plan step by step.
    
    Runs each unexecuted step in the plan, invokes appropriate
    specialized functions, and updates state with results.
    
    Args:
        state: Current graph state
    
    Returns:
        Updated state with execution results
    """
    logger.info("="*60)
    logger.info("PLANNER EXECUTION NODE: Executing plan steps")
    logger.info("="*60)
    
    try:
        plan_dict = state.get("plan")
        if not plan_dict:
            logger.warning("No plan found in state")
            return {"messages": state["messages"] + [
                AIMessage(content="No execution plan found.")
            ]}
        
        plan = ExecutionPlan.from_dict(plan_dict)
        messages = list(state["messages"])
        tool_results = dict(state.get("tool_results", {}))
        
        # Execute each step
        for step in plan.steps:
            if step.executed:
                logger.info(f"Step {step.id} already executed, skipping")
                continue
            
            logger.info(f"Executing step: {step.id} - {step.action}")
            
            # Execute based on action type
            result = execute_step(step, state, tool_results)
            
            # Update step
            step.executed = True
            step.result = result
            step.timestamp = datetime.now().isoformat()
            
            # Store result
            tool_results[step.id] = result
            
            # Add tool message
            tool_msg = ToolMessage(
                content=f"Step {step.id} ({step.action}) completed: {_summarize_result(result)}",
                tool_call_id=step.id
            )
            messages.append(tool_msg)
            
            logger.info(f"Step {step.id} executed successfully")
        
        # Create summary message
        summary = f"Executed {len([s for s in plan.steps if s.executed])} plan steps successfully."
        messages.append(AIMessage(content=summary))
        
        return {
            "messages": messages,
            "plan": plan.to_dict(),
            "tool_results": tool_results
        }
        
    except Exception as e:
        logger.error(f"Error in planner execution: {str(e)}", exc_info=True)
        return {
            "messages": state["messages"] + [
                AIMessage(content=f"Execution error: {str(e)}")
            ]
        }


def execute_step(step, state: GraphState, tool_results: Dict[str, Any]) -> Any:
    """
    Execute a single plan step.
    
    Args:
        step: PlanStep to execute
        state: Current graph state
        tool_results: Accumulated tool results
    
    Returns:
        Execution result
    """
    action_map = {
        "extract_preferences": lambda: extract_preferences_action(state),
        "flight_search": lambda: execute_flight_search(state, step.params),
        "hotel_search": lambda: execute_hotel_search(state, step.params),
        "activity_search": lambda: execute_activity_search(state, step.params),
        "compose_itinerary": lambda: execute_itinerary_composition(state, step.params, tool_results)
    }
    
    action_func = action_map.get(step.action)
    if not action_func:
        logger.warning(f"Unknown action: {step.action}")
        return {"error": f"Unknown action: {step.action}"}
    
    try:
        return action_func()
    except Exception as e:
        logger.error(f"Error executing {step.action}: {str(e)}")
        return {"error": str(e)}


def extract_preferences_action(state: GraphState) -> Dict[str, Any]:
    """
    Extract user preferences from query.
    
    Args:
        state: Current graph state
    
    Returns:
        Extracted preferences
    """
    from agents.planner import extract_user_preferences
    from langchain_openai import ChatOpenAI
    from utils.config import get_config
    
    config = get_config()
    llm = ChatOpenAI(model=config["llm"]["model"])
    
    query = state["messages"][0].content if state["messages"] else ""
    preferences = extract_user_preferences(query, llm)
    
    logger.info(f"Extracted preferences: destination={preferences.destination}, duration={preferences.duration_days}")
    
    return preferences.to_dict()


def _summarize_result(result: Any) -> str:
    """Summarize execution result for logging."""
    if isinstance(result, dict):
        if "error" in result:
            return f"Error: {result['error']}"
        elif "itinerary" in result:
            return "Itinerary created"
        elif "flights" in result:
            return f"Found {len(result.get('flights', []))} flights"
        elif "hotels" in result:
            return f"Found {len(result.get('hotels', []))} hotels"
        elif "activities" in result:
            return f"Found {len(result.get('activities', []))} activities"
        return "Completed"
    return str(result)[:50]