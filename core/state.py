"""
State management for the itinerary planner system.
Defines the shared state structure passed between nodes.
"""

from typing import TypedDict, List, Dict, Any, Optional
from dataclasses import dataclass, field
from datetime import datetime
from langchain_core.messages import BaseMessage, HumanMessage


@dataclass
class PlanStep:
    """Represents a single step in the execution plan."""
    id: str
    action: str  # e.g., "flight_search", "hotel_search", "compose_itinerary"
    params: Dict[str, Any] = field(default_factory=dict)
    executed: bool = False
    result: Optional[Any] = None
    timestamp: Optional[str] = None


@dataclass
class ExecutionPlan:
    """Structured execution plan generated by Planner."""
    steps: List[PlanStep] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "steps": [
                {
                    "id": step.id,
                    "action": step.action,
                    "params": step.params,
                    "executed": step.executed,
                    "result": step.result,
                    "timestamp": step.timestamp
                }
                for step in self.steps
            ],
            "metadata": self.metadata
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "ExecutionPlan":
        """Create ExecutionPlan from dictionary."""
        steps = [
            PlanStep(
                id=s["id"],
                action=s["action"],
                params=s.get("params", {}),
                executed=s.get("executed", False),
                result=s.get("result"),
                timestamp=s.get("timestamp")
            )
            for s in data.get("steps", [])
        ]
        return cls(steps=steps, metadata=data.get("metadata", {}))


class GraphState(TypedDict):
    """
    Shared state object passed between all nodes in the graph.
    
    This is the central communication mechanism for the multi-agent system.
    All nodes read from and write to this state.
    """
    # Conversation history
    messages: List[BaseMessage]
    
    # Execution plan (JSON structure)
    plan: Optional[Dict[str, Any]]  # ExecutionPlan.to_dict()
    
    # Current itinerary being built/modified
    current_itinerary: Optional[Dict[str, Any]]
    
    # User preferences and constraints
    user_preferences: Dict[str, Any]
    
    # Routing decision
    next_agent: str  # "FLIGHT", "HOTEL", "ACTIVITY", "ITINERARY", "REASONING", "END"
    
    # Tool results cache
    tool_results: Dict[str, Any]
    
    # Metadata
    metadata: Dict[str, Any]


def create_initial_state(query: str, **kwargs) -> GraphState:
    """
    Create initial state for a new conversation.
    
    Args:
        query: Initial user query
        **kwargs: Additional context (budget, dates, etc.)
    
    Returns:
        Initialized GraphState
    """
    return GraphState(
        messages=[HumanMessage(content=query)],
        plan=None,
        current_itinerary=None,
        user_preferences=kwargs.get("user_preferences", {}),
        next_agent="",
        tool_results={},
        metadata={
            "created_at": datetime.now().isoformat(),
            "query": query,
            **kwargs
        }
    )


@dataclass
class UserPreferences:
    """Structured user preferences extracted from query."""
    destination: Optional[str] = None
    duration_days: Optional[int] = None
    budget: Optional[str] = None  # "budget", "mid-range", "luxury"
    interests: List[str] = field(default_factory=list)
    start_date: Optional[str] = None
    end_date: Optional[str] = None
    travelers: int = 1
    accommodation_type: Optional[str] = None
    dietary_restrictions: List[str] = field(default_factory=list)
    mobility_constraints: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "destination": self.destination,
            "duration_days": self.duration_days,
            "budget": self.budget,
            "interests": self.interests,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "travelers": self.travelers,
            "accommodation_type": self.accommodation_type,
            "dietary_restrictions": self.dietary_restrictions,
            "mobility_constraints": self.mobility_constraints
        }


@dataclass
class DayItinerary:
    """Represents itinerary for a single day."""
    day_number: int
    date: Optional[str] = None
    location: Optional[str] = None
    activities: List[Dict[str, Any]] = field(default_factory=list)
    meals: List[Dict[str, Any]] = field(default_factory=list)
    accommodation: Optional[Dict[str, Any]] = None
    transportation: List[Dict[str, Any]] = field(default_factory=list)
    notes: Optional[str] = None
    estimated_cost: Optional[float] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "day_number": self.day_number,
            "date": self.date,
            "location": self.location,
            "activities": self.activities,
            "meals": self.meals,
            "accommodation": self.accommodation,
            "transportation": self.transportation,
            "notes": self.notes,
            "estimated_cost": self.estimated_cost
        }


@dataclass
class Itinerary:
    """Complete trip itinerary."""
    destination: str
    start_date: Optional[str] = None
    end_date: Optional[str] = None
    duration_days: int = 0
    days: List[DayItinerary] = field(default_factory=list)
    total_estimated_cost: Optional[float] = None
    summary: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "destination": self.destination,
            "start_date": self.start_date,
            "end_date": self.end_date,
            "duration_days": self.duration_days,
            "days": [day.to_dict() for day in self.days],
            "total_estimated_cost": self.total_estimated_cost,
            "summary": self.summary,
            "metadata": self.metadata
        }